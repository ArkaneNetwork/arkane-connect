name: "Deploy ecs Application"
description: "Deploy ecs Application"
inputs:
  aws_region:
    default: eu-west-1
    description: name of the aws region to deploy to
    required: false
  aws_role:
    description: name of the role to use
    required: true
  cluster_name:
    description: name of the ecs cluster
    required: true
  ecr_repo:
    description: name of the ecr repository
    required: true
  environment:
    default: qa
    description: The environment to deploy to
    required: true
  self_managed_task:
    default: false
    description: Self Managed Task definition
    required: false
  service_name:
    description: Name of the service
    required: true
  tag_to_deploy:
    description: name of the tag you want to deploy
    required: true
  token:
    description: The VENLY_GITHUB_ACTIONS_TOKEN
    required: true
runs:
  using: "composite"
  steps:
    # Checkout code
    - name: üîë ConfigureAwsCredentials üîë
      uses: aws-actions/configure-aws-credentials@v2
      id: ecr-credentials
      with:
        aws-region: ${{ inputs.aws_region }}
        role-to-assume: arn:aws:iam::289334807197:role/github-actions-oidc-GitHubActionsServiceRole-6CE9XOJGN8I8
        role-session-name: OIDCSession
        mask-aws-account-id: false
    
    - name: üê≥ Read docker labels üê≥
      shell: bash
      id: read-labels
      run: |
        manifest=$(aws ecr batch-get-image --repository-name ${{ inputs.ecr_repo }} --image-id imageTag=${{ inputs.tag_to_deploy }} --accepted-media-types "application/vnd.docker.distribution.manifest.v1+json" --output json | jq -r '.images[].imageManifest')
        labels=$(echo "$manifest" | jq -r '.history[].v1Compatibility | fromjson | .config.Labels')
        json=$(echo $labels | jq -r | jq -r 'select(. != null)')
        output=$(echo "$json" | jq -r 'to_entries[] | "\(.key)=\(.value)"')
        # Create environment in GITHUB_ENV for each label
        while IFS= read -r line; do
          modified_line=$(echo "$line" | sed 's/\./_/g')
          echo "$modified_line" >> $GITHUB_ENV
        done <<< "$output"
        echo $output
    
    - name: ‚úÖ Checkout ‚úÖ
      uses: actions/checkout@v3
      with:
        ref: ${{ env.org_opencontainers_image_revision }}
    
    - name: Branch to Deploy
      shell: bash
      run: echo -e "üîß Following branch will be build ${{ github.event.workflow_run.head_branch }} üîß"
    
    - name: üê≥ Add cluster tag to image if it doesn't exists for ${{ env.org_opencontainers_image_revision }} üê≥
      id: cluster-tag
      shell: bash
      run: |
        repository_name="${{ inputs.ecr_repo }}"
        image_tag="${{ env.org_opencontainers_image_revision }}"

        # Check if the image with the specified tag exists with the '${{ inputs.cluster_name }}' tag
        if aws ecr describe-images --repository-name "$repository_name" --image-ids imageTag="$image_tag" --output text 2>/dev/null | grep "${{ inputs.cluster_name }}"; then
          echo "The image with tag $image_tag exists with the '${{ inputs.cluster_name }}' tag"
        else
          echo "The image with tag $image_tag does not exist with the '${{ inputs.cluster_name }}' tag, creating..."
          MANIFEST=$(aws ecr batch-get-image --repository-name $repository_name --image-ids imageTag=$image_tag --output json | jq --raw-output --join-output '.images[0].imageManifest')
          aws ecr put-image --repository-name $repository_name --image-tag ${{ inputs.cluster_name }} --image-manifest "$MANIFEST"
        fi
    
    - name: üîë ConfigureAwsCredentials üîë
      uses: aws-actions/configure-aws-credentials@v2
      id: credentials
      with:
        aws-region: ${{ inputs.aws_region }}
        role-to-assume: ${{ inputs.aws_role }}
        role-session-name: OIDCSession
        mask-aws-account-id: false
    
    - name: üîß Adapt task definition üîß 
      if: ${{ inputs.self_managed_task == "true" }}
      shell: bash
      run: |
        input=${{ inputs.service_name }}
        base_service_name=$(echo $input | awk -F '-${{ inputs.environment }}-service-fargate' '{print $1}')
        echo $base_service_name
        echo $(cat task-definition/${{ inputs.environment }}/$base_service_name.json | jq 'del(
                  .taskDefinitionArn,
                  .requiresAttributes,
                  .compatibilities,
                  .revision,
                  .status,
                  .registeredAt,
                  .registeredBy
              )') > task-definition-${{ inputs.service_name }}.json
        task=$(<task-definition-${{ inputs.service_name }}.json)
        echo $task > ${{ inputs.service_name }}.json
    
    - name: üîß Download task definition üîß
      if: ${{ inputs.self_managed_task == "false" }}
      run: |
        # Fetch the task definition ARN from the ECS service
        task_definition_arn=$(aws ecs describe-services --cluster ${{ inputs.cluster_name }} --services ${{ inputs.service_name }} --query 'services[0].taskDefinition' --output text)
        # Extract the task definition family name from the ARN
        task_definition_family=$(echo $task_definition_arn | awk -F '/' '{print $2}')
        # Describe the task definition using the extracted family name
        aws ecs describe-task-definition --task-definition $task_definition_family > ${{ inputs.service_name }}.json
        echo $(cat ${{ inputs.service_name }}.json | jq 'del(
                  .taskDefinitionArn,
                  .requiresAttributes,
                  .compatibilities,
                  .revision,
                  .status,
                  .registeredAt,
                  .registeredBy
              )') > task-definition-${{ inputs.service_name }}.json
        task=$(<task-definition-${{ inputs.service_name }}.json)
        echo $task > ${{ inputs.service_name }}.json  
    
    - name: üîß Extract the container name üîß
      shell: bash
      run: |
        # Read the JSON file and extract container names
          container_names=($(jq -r '.containerDefinitions[].name' ${{ inputs.service_name }}.json))
          filtered_names=()
          # Iterate over container names
          for name in "${container_names[@]}"; do
              # Check if the name is not "datadog-agent" or "log_router"
              if [[ $name != "datadog-agent" && $name != "log_router" ]]; then
                  filtered_names+=("$name")
              fi
          done
          # Print the filtered container names
          if [ ${#filtered_names[@]} -gt 0 ]; then
              printf '%s\n' "${filtered_names[@]}"
              echo "container_name=${filtered_names[@]}" >> $GITHUB_ENV
          else
              echo "No containers found other than 'datadog-agent' and 'log_router'."
          fi
    
    - name: üê≥ Add opencontainer labels üê≥
      id: labels
      shell: bash
      run: |
        #!/bin/bash
        # Set the labels and their corresponding values
        revision_label="org.opencontainers.image.revision"
        source_label="org.opencontainers.image.source"
        version_label="org.opencontainers.image.version"
        created_label="org.opencontainers.image.created"
        revision_value="${{ env.org_opencontainers_image_revision }}"
        source_value="${{ env.org_opencontainers_image_source }}"
        version_value="${{ env.org_opencontainers_image_version }}"
        created_value="${{ env.org_opencontainers_image_created }}"

        # Read the task definition file
        task_definition_file="${{ inputs.service_name }}.json"
        task_definition=$(cat "$task_definition_file")

        # Add the labels to the task definition
        updated_task_definition=$(jq --arg revision_label "$revision_label" --arg revision_value "$revision_value" \
            --arg source_label "$source_label" --arg source_value "$source_value" \
            --arg version_label "$version_label" --arg version_value "$version_value" \
            --arg created_label "$created_label" --arg created_value "$created_value" \
            '.containerDefinitions[].dockerLabels += {
                ($revision_label): $revision_value,
                ($source_label): $source_value,
                ($version_label): $version_value,
                ($created_label): $created_value
            }' <<< "$task_definition")

        # Save the updated task definition back to the file
        echo "$updated_task_definition" > "$task_definition_file"
    
    - name: üîß Render task definition file üîß
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition-${{ inputs.service_name }}.json
        container-name: ${{ env.container_name }}
        image: 289334807197.dkr.ecr.eu-west-1.amazonaws.com/${{ inputs.ecr_repo }}:${{ inputs.tag_to_deploy }}
    
    - name: üîß Save rendered task definition üîß
      id: save-task-def
      shell: bash
      run: |
        cat "${{ steps.task-def.outputs.task-definition }}"
        cat "${{ steps.task-def.outputs.task-definition }}" > ${{ inputs.service_name }}.json
      env:
        TASK_DEF: ${{ steps.task-def-version.outputs.task-definition }}
    
    # - uses: trstringer/manual-approval@v1
    #   if: ${{ inputs.environment == 'staging' || inputs.environment == 'prd' }}
    #   with:
    #     secret: ${{ inputs.token }}
    #     approvers: Admins
    #     minimum-approvals: 1
    #     issue-title: "Deploying ${{ inputs.service_name }} ${{ env.OPENCONTAINERS_VERSION }} to ${{ inputs.environment }}"
    #     issue-body: "Deploying ${{ inputs.service_name }} ${{ env.OPENCONTAINERS_VERSION }} to ${{ inputs.environment }}. Approve/Deny"
    #     exclude-workflow-initiator-as-approver: false
    #     additional-approved-words: "Approve, LetTheBeastGo"
    #     additional-denied-words: "Deny, StopInTheNameOfLove"
    
    - name: üë∑ Deploy Amazon ECS task definition üë∑
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ inputs.service_name }}
        cluster: ${{ inputs.cluster_name }}
        wait-for-service-stability: true
        force-new-deployment: true
    
    - name: üë∑ Update Tags for Service üë∑
      shell: bash
      run: |
        ACCOUNTID=$(aws sts get-caller-identity --query "Account" --output text)
        aws ecs tag-resource --resource-arn arn:aws:ecs:${{ inputs.aws_region }}:${ACCOUNTID}:service/${{ inputs.cluster_name }}/${{ inputs.service_name }} \
        --tags key=OPENCONTAINERS_REVISION,value=${{ env.org_opencontainers_image_revision }} \
          key=DD_VERSION,value=${{ env.org_opencontainers_image_version }} \
          key=OPENCONTAINERS_VERSION,value=${{ env.org_opencontainers_image_version }} \
          key=OPENCONTAINERS_CREATED,value=${{ env.org_opencontainers_image_created }} \
          key=OPENCONTAINERS_SOURCE,value=${{ env.org_opencontainers_image_source }} \
          key=GITHUB_REPO,value=${{ github.repository }} \
          key=DEPLOY_EVENT,value=${{ github.event	 }} \
          key=BUILD_BRANCH,value=${{ github.ref_name }} \
          key=DEPLOY_USER,value=${{ github.triggering_actor }} \
          --region ${{ inputs.aws_region }}
    
    - name: üë∑ Update Tags for Tasks üë∑
      shell: bash
      run: |
        ACCOUNTID=$(aws sts get-caller-identity --query "Account" --output text)
        for i in $(aws ecs list-tasks --cluster ${{ inputs.cluster_name }}  --query 'taskArns' --output json --region ${{ inputs.aws_region }} | jq -r .[]); do 
          aws ecs tag-resource --resource-arn $i \
          --tags key=OPENCONTAINERS_REVISION,value=${{ env.org_opencontainers_image_revision }} \
          key=DD_VERSION,value=${{ env.org_opencontainers_image_version }} \
          key=OPENCONTAINERS_VERSION,value=${{ env.org_opencontainers_image_version }} \
          key=OPENCONTAINERS_CREATED,value=${{ env.org_opencontainers_image_created }} \
          key=OPENCONTAINERS_SOURCE,value=${{ env.org_opencontainers_image_source }} \
          key=GITHUB_REPO,value=${{ github.repository }} \
          key=DEPLOY_EVENT,value=${{ github.event	 }} \
          key=BUILD_BRANCH,value=${{ github.ref_name }} \
          key=DEPLOY_USER,value=${{ github.triggering_actor }} \
          --region ${{ inputs.aws_region }}
        done
